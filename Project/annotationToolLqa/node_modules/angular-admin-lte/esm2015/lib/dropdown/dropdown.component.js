/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ElementRef, EventEmitter, Input, NgZone, Output, Renderer2, TemplateRef, ViewChild } from '@angular/core';
import { removeListeners } from '../helpers';
export class DropdownToggleComponent {
}
DropdownToggleComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown-toggle',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
DropdownToggleComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }],
    toggleElement: [{ type: ContentChild, args: ['toggleElement',] }]
};
if (false) {
    /** @type {?} */
    DropdownToggleComponent.prototype.templateRef;
    /** @type {?} */
    DropdownToggleComponent.prototype.toggleElement;
}
export class DropdownMenuComponent {
}
DropdownMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown-menu',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
DropdownMenuComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
if (false) {
    /** @type {?} */
    DropdownMenuComponent.prototype.templateRef;
}
export class DropdownComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} elementRef [description]
     * @param {?} ngZone [description]
     * @param {?} renderer2 [description]
     */
    constructor(changeDetectorRef, elementRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.elementRef = elementRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.buttonStyleClass = 'btn dropdown-toggle';
        this.buttonBackgroudColor = 'default';
        this.contentStyleClass = 'dropdown-menu';
        this.isCollapsed = true;
        this.isWrapper = true;
        this.styleClass = 'dropdown';
        this.onCollapseStart = new EventEmitter();
        this.onCollapseDone = new EventEmitter();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        /** @type {?} */
        const toggleNativeElement = this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement ?
            this.dropdownToggleComponent.toggleElement.nativeElement : this.toggleElement ?
            this.toggleElement : this.defaultToggleElement ?
            this.defaultToggleElement.nativeElement : null;
        if (toggleNativeElement) {
            this.ngZone.runOutsideAngular(() => {
                this.listeners.push(this.renderer2.listen(toggleNativeElement, 'click', (event) => {
                    this.toggleDropdown(event);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        this.unBindDocumentClickListener();
        removeListeners(this.listeners);
    }
    /**
     * [toggle description]
     * \@method toggle
     * @param {?} event [description]
     * @return {?}
     */
    toggleDropdown(event) {
        event.preventDefault();
        this.isCollapsed = !this.isCollapsed;
        if (!this.isCollapsed) {
            this.ngZone.runOutsideAngular(() => {
                setTimeout(() => {
                    this.bindDocumentClickListener();
                });
            });
        }
        else {
            this.unBindDocumentClickListener();
        }
    }
    /**
     * [collapseStart description]
     * \@method collapseStart
     * @param {?} event [description]
     * @return {?}
     */
    collapseStart(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [collapseDone description]
     * \@method collapseDone
     * @param {?} event [description]
     * @return {?}
     */
    collapseDone(event) {
        this.onCollapseStart.emit(event);
    }
    /**
     * [bindDocumentClickListener description]
     * \@method bindDocumentClickListener
     * @return {?}
     */
    bindDocumentClickListener() {
        this.ngZone.runOutsideAngular(() => {
            this.documentClickListener = this.renderer2.listen('document', 'click', () => {
                if (!this.isCollapsed) {
                    this.isCollapsed = true;
                    this.unBindDocumentClickListener();
                    this.changeDetectorRef.detectChanges();
                }
            });
        });
    }
    /**
     * [unBindDocumentClickListener description]
     * \@method unBindDocumentClickListener
     * @return {?}
     */
    unBindDocumentClickListener() {
        if (this.documentClickListener) {
            this.documentClickListener();
        }
    }
}
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-dropdown, [mk-dropdown]',
                template: `<ng-template #innerTemplate>
  <ng-container *ngIf="this.dropdownToggleComponent && this.dropdownToggleComponent.toggleElement; else noToggleElement" [ngTemplateOutlet]="dropdownToggleComponent.templateRef"></ng-container>
  <ng-template #noToggleElement>
    <button *ngIf="toggleText || dropdownToggleComponent" [mkColor]="buttonBackgroudColor" mkColorProperty="background-color" mkColorPrefix="btn" [ngClass]="buttonStyleClass" #toggleElement>
      {{toggleText}}
      <ng-container [ngTemplateOutlet]="dropdownToggleComponent?.templateRef"></ng-container>
    </button>
  </ng-template>
  <ul [ngClass]="contentStyleClass" [collapseAnimation]="isCollapsed" (collapseAnimation.start)="collapseStart($event)" (collapseAnimation.done)="collapseDone($event)">
    <ng-container *ngIf="dropdownMenuComponent; else noDropdownMenuComponent" [ngTemplateOutlet]="dropdownMenuComponent.templateRef"></ng-container>
    <ng-template #noDropdownMenuComponent>
      <ng-content></ng-content>
    </ng-template>
  </ul>
</ng-template>

<div *ngIf="isWrapper; else noWrapper" [ngClass]="styleClass">
  <ng-container *ngTemplateOutlet="innerTemplate"></ng-container>
</div>

<ng-template #noWrapper>
  <ng-container *ngTemplateOutlet="innerTemplate"></ng-container>
</ng-template>
`,
                styles: [`.dropdown-menu{display:block}.dropdown-menu.collapsing:not(.un-collapse){transition-property:height,padding-top,padding-bottom;padding-top:0;padding-bottom:0}`],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
DropdownComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: ElementRef },
    { type: NgZone },
    { type: Renderer2 }
];
DropdownComponent.propDecorators = {
    buttonStyleClass: [{ type: Input }],
    buttonBackgroudColor: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    isCollapsed: [{ type: Input }],
    isWrapper: [{ type: Input }],
    styleClass: [{ type: Input }],
    toggleElement: [{ type: Input }],
    toggleText: [{ type: Input }],
    onCollapseStart: [{ type: Output }],
    onCollapseDone: [{ type: Output }],
    dropdownToggleComponent: [{ type: ContentChild, args: [DropdownToggleComponent,] }],
    dropdownMenuComponent: [{ type: ContentChild, args: [DropdownMenuComponent,] }],
    defaultToggleElement: [{ type: ViewChild, args: ['toggleElement',] }]
};
if (false) {
    /** @type {?} */
    DropdownComponent.prototype.documentClickListener;
    /** @type {?} */
    DropdownComponent.prototype.listeners;
    /** @type {?} */
    DropdownComponent.prototype.buttonStyleClass;
    /** @type {?} */
    DropdownComponent.prototype.buttonBackgroudColor;
    /** @type {?} */
    DropdownComponent.prototype.contentStyleClass;
    /** @type {?} */
    DropdownComponent.prototype.isCollapsed;
    /** @type {?} */
    DropdownComponent.prototype.isWrapper;
    /** @type {?} */
    DropdownComponent.prototype.styleClass;
    /** @type {?} */
    DropdownComponent.prototype.toggleElement;
    /** @type {?} */
    DropdownComponent.prototype.toggleText;
    /** @type {?} */
    DropdownComponent.prototype.onCollapseStart;
    /** @type {?} */
    DropdownComponent.prototype.onCollapseDone;
    /** @type {?} */
    DropdownComponent.prototype.dropdownToggleComponent;
    /** @type {?} */
    DropdownComponent.prototype.dropdownMenuComponent;
    /** @type {?} */
    DropdownComponent.prototype.defaultToggleElement;
    /** @type {?} */
    DropdownComponent.prototype.changeDetectorRef;
    /** @type {?} */
    DropdownComponent.prototype.elementRef;
    /** @type {?} */
    DropdownComponent.prototype.ngZone;
    /** @type {?} */
    DropdownComponent.prototype.renderer2;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1hZG1pbi1sdGUvIiwic291cmNlcyI6WyJsaWIvZHJvcGRvd24vZHJvcGRvd24uY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBRUwsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFFTixNQUFNLEVBQ04sU0FBUyxFQUNULFdBQVcsRUFDWCxTQUFTLEVBQ1YsTUFBTSxlQUFlLENBQUM7QUFJdkIsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLFlBQVksQ0FBQztBQVUzQyxNQUFNOzs7WUFMTCxTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsUUFBUSxFQUFFLG1FQUFtRTtnQkFDN0UsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07YUFDaEQ7OzswQkFFRSxTQUFTLFNBQUMsYUFBYTs0QkFDdkIsWUFBWSxTQUFDLGVBQWU7Ozs7Ozs7O0FBWS9CLE1BQU07OztZQUxMLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsa0JBQWtCO2dCQUM1QixRQUFRLEVBQUUsbUVBQW1FO2dCQUM3RSxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7OzBCQUVFLFNBQVMsU0FBQyxhQUFhOzs7Ozs7QUFvQzFCLE1BQU07Ozs7Ozs7O0lBNEJKLFlBQ1UsbUJBQ0EsWUFDQSxRQUNBO1FBSEEsc0JBQWlCLEdBQWpCLGlCQUFpQjtRQUNqQixlQUFVLEdBQVYsVUFBVTtRQUNWLFdBQU0sR0FBTixNQUFNO1FBQ04sY0FBUyxHQUFULFNBQVM7eUJBOUJDLEVBQUU7Z0NBRWEscUJBQXFCO29DQUNqQixTQUFTO2lDQUNaLGVBQWU7MkJBQ3JCLElBQUk7eUJBQ04sSUFBSTswQkFDSCxVQUFVOytCQUlKLElBQUksWUFBWSxFQUFF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QUN0QyxRQUFRLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0NBdUJYO2dCQUNDLE1BQU0sRUFBRSxDQUFDLGdLQUFnSyxDQUFDO2dCQUMxSyxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7OztZQTVFQyxpQkFBaUI7WUFHakIsVUFBVTtZQUdWLE1BQU07WUFHTixTQUFTOzs7K0JBd0VSLEtBQUs7bUNBQ0wsS0FBSztnQ0FDTCxLQUFLOzBCQUNMLEtBQUs7d0JBQ0wsS0FBSzt5QkFDTCxLQUFLOzRCQUNMLEtBQUs7eUJBQ0wsS0FBSzs4QkFFTCxNQUFNOzZCQUNOLE1BQU07c0NBRU4sWUFBWSxTQUFDLHVCQUF1QjtvQ0FDcEMsWUFBWSxTQUFDLHFCQUFxQjttQ0FFbEMsU0FBUyxTQUFDLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBOZ1pvbmUsXG4gIE9uRGVzdHJveSxcbiAgT3V0cHV0LFxuICBSZW5kZXJlcjIsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGRcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7QW5pbWF0aW9uRXZlbnR9IGZyb20gJy4uL2FuaW1hdGlvbnMvYW5pbWF0aW9ucy5pbnRlcmZhY2UnO1xuXG5pbXBvcnQge3JlbW92ZUxpc3RlbmVyc30gZnJvbSAnLi4vaGVscGVycyc7XG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay1kcm9wZG93bi10b2dnbGUnLFxuICB0ZW1wbGF0ZTogJzxuZy10ZW1wbGF0ZSAjdGVtcGxhdGVSZWY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+JyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd25Ub2dnbGVDb21wb25lbnQge1xuICBAVmlld0NoaWxkKCd0ZW1wbGF0ZVJlZicpIHB1YmxpYyB0ZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcbiAgQENvbnRlbnRDaGlsZCgndG9nZ2xlRWxlbWVudCcpIHB1YmxpYyB0b2dnbGVFbGVtZW50OiBFbGVtZW50UmVmO1xufVxuXG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay1kcm9wZG93bi1tZW51JyxcbiAgdGVtcGxhdGU6ICc8bmctdGVtcGxhdGUgI3RlbXBsYXRlUmVmPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L25nLXRlbXBsYXRlPicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIERyb3Bkb3duTWVudUNvbXBvbmVudCB7XG4gIEBWaWV3Q2hpbGQoJ3RlbXBsYXRlUmVmJykgcHVibGljIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xufVxuXG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay1kcm9wZG93biwgW21rLWRyb3Bkb3duXScsXG4gIHRlbXBsYXRlOiBgPG5nLXRlbXBsYXRlICNpbm5lclRlbXBsYXRlPlxuICA8bmctY29udGFpbmVyICpuZ0lmPVwidGhpcy5kcm9wZG93blRvZ2dsZUNvbXBvbmVudCAmJiB0aGlzLmRyb3Bkb3duVG9nZ2xlQ29tcG9uZW50LnRvZ2dsZUVsZW1lbnQ7IGVsc2Ugbm9Ub2dnbGVFbGVtZW50XCIgW25nVGVtcGxhdGVPdXRsZXRdPVwiZHJvcGRvd25Ub2dnbGVDb21wb25lbnQudGVtcGxhdGVSZWZcIj48L25nLWNvbnRhaW5lcj5cbiAgPG5nLXRlbXBsYXRlICNub1RvZ2dsZUVsZW1lbnQ+XG4gICAgPGJ1dHRvbiAqbmdJZj1cInRvZ2dsZVRleHQgfHwgZHJvcGRvd25Ub2dnbGVDb21wb25lbnRcIiBbbWtDb2xvcl09XCJidXR0b25CYWNrZ3JvdWRDb2xvclwiIG1rQ29sb3JQcm9wZXJ0eT1cImJhY2tncm91bmQtY29sb3JcIiBta0NvbG9yUHJlZml4PVwiYnRuXCIgW25nQ2xhc3NdPVwiYnV0dG9uU3R5bGVDbGFzc1wiICN0b2dnbGVFbGVtZW50PlxuICAgICAge3t0b2dnbGVUZXh0fX1cbiAgICAgIDxuZy1jb250YWluZXIgW25nVGVtcGxhdGVPdXRsZXRdPVwiZHJvcGRvd25Ub2dnbGVDb21wb25lbnQ/LnRlbXBsYXRlUmVmXCI+PC9uZy1jb250YWluZXI+XG4gICAgPC9idXR0b24+XG4gIDwvbmctdGVtcGxhdGU+XG4gIDx1bCBbbmdDbGFzc109XCJjb250ZW50U3R5bGVDbGFzc1wiIFtjb2xsYXBzZUFuaW1hdGlvbl09XCJpc0NvbGxhcHNlZFwiIChjb2xsYXBzZUFuaW1hdGlvbi5zdGFydCk9XCJjb2xsYXBzZVN0YXJ0KCRldmVudClcIiAoY29sbGFwc2VBbmltYXRpb24uZG9uZSk9XCJjb2xsYXBzZURvbmUoJGV2ZW50KVwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJkcm9wZG93bk1lbnVDb21wb25lbnQ7IGVsc2Ugbm9Ecm9wZG93bk1lbnVDb21wb25lbnRcIiBbbmdUZW1wbGF0ZU91dGxldF09XCJkcm9wZG93bk1lbnVDb21wb25lbnQudGVtcGxhdGVSZWZcIj48L25nLWNvbnRhaW5lcj5cbiAgICA8bmctdGVtcGxhdGUgI25vRHJvcGRvd25NZW51Q29tcG9uZW50PlxuICAgICAgPG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PlxuICAgIDwvbmctdGVtcGxhdGU+XG4gIDwvdWw+XG48L25nLXRlbXBsYXRlPlxuXG48ZGl2ICpuZ0lmPVwiaXNXcmFwcGVyOyBlbHNlIG5vV3JhcHBlclwiIFtuZ0NsYXNzXT1cInN0eWxlQ2xhc3NcIj5cbiAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImlubmVyVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI25vV3JhcHBlcj5cbiAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImlubmVyVGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbjwvbmctdGVtcGxhdGU+XG5gLFxuICBzdHlsZXM6IFtgLmRyb3Bkb3duLW1lbnV7ZGlzcGxheTpibG9ja30uZHJvcGRvd24tbWVudS5jb2xsYXBzaW5nOm5vdCgudW4tY29sbGFwc2Upe3RyYW5zaXRpb24tcHJvcGVydHk6aGVpZ2h0LHBhZGRpbmctdG9wLHBhZGRpbmctYm90dG9tO3BhZGRpbmctdG9wOjA7cGFkZGluZy1ib3R0b206MH1gXSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgRHJvcGRvd25Db21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0LCBPbkRlc3Ryb3kge1xuICBwcml2YXRlIGRvY3VtZW50Q2xpY2tMaXN0ZW5lcjogRnVuY3Rpb247XG4gIHByaXZhdGUgbGlzdGVuZXJzID0gW107XG5cbiAgQElucHV0KCkgcHVibGljIGJ1dHRvblN0eWxlQ2xhc3MgPSAnYnRuIGRyb3Bkb3duLXRvZ2dsZSc7XG4gIEBJbnB1dCgpIHB1YmxpYyBidXR0b25CYWNrZ3JvdWRDb2xvciA9ICdkZWZhdWx0JztcbiAgQElucHV0KCkgcHVibGljIGNvbnRlbnRTdHlsZUNsYXNzID0gJ2Ryb3Bkb3duLW1lbnUnO1xuICBASW5wdXQoKSBwdWJsaWMgaXNDb2xsYXBzZWQgPSB0cnVlO1xuICBASW5wdXQoKSBwdWJsaWMgaXNXcmFwcGVyID0gdHJ1ZTtcbiAgQElucHV0KCkgcHVibGljIHN0eWxlQ2xhc3MgPSAnZHJvcGRvd24nO1xuICBASW5wdXQoKSBwdWJsaWMgdG9nZ2xlRWxlbWVudDogRWxlbWVudDtcbiAgQElucHV0KCkgcHVibGljIHRvZ2dsZVRleHQ6IHN0cmluZztcblxuICBAT3V0cHV0KCkgcHVibGljIG9uQ29sbGFwc2VTdGFydCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgQE91dHB1dCgpIHB1YmxpYyBvbkNvbGxhcHNlRG9uZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICBAQ29udGVudENoaWxkKERyb3Bkb3duVG9nZ2xlQ29tcG9uZW50KSBwdWJsaWMgZHJvcGRvd25Ub2dnbGVDb21wb25lbnQ6IERyb3Bkb3duVG9nZ2xlQ29tcG9uZW50O1xuICBAQ29udGVudENoaWxkKERyb3Bkb3duTWVudUNvbXBvbmVudCkgcHVibGljIGRyb3Bkb3duTWVudUNvbXBvbmVudDogRHJvcGRvd25NZW51Q29tcG9uZW50O1xuXG4gIEBWaWV3Q2hpbGQoJ3RvZ2dsZUVsZW1lbnQnKSBwcml2YXRlIGRlZmF1bHRUb2dnbGVFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBjaGFuZ2VEZXRlY3RvclJlZiBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSBlbGVtZW50UmVmIFtkZXNjcmlwdGlvbl1cbiAgICogQHBhcmFtIG5nWm9uZSBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSByZW5kZXJlcjIgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjaGFuZ2VEZXRlY3RvclJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgbmdab25lOiBOZ1pvbmUsXG4gICAgcHJpdmF0ZSByZW5kZXJlcjI6IFJlbmRlcmVyMlxuICApIHt9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmdBZnRlclZpZXdJbml0XG4gICAqL1xuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgY29uc3QgdG9nZ2xlTmF0aXZlRWxlbWVudCA9IHRoaXMuZHJvcGRvd25Ub2dnbGVDb21wb25lbnQgJiYgdGhpcy5kcm9wZG93blRvZ2dsZUNvbXBvbmVudC50b2dnbGVFbGVtZW50ID9cbiAgICAgIHRoaXMuZHJvcGRvd25Ub2dnbGVDb21wb25lbnQudG9nZ2xlRWxlbWVudC5uYXRpdmVFbGVtZW50IDogdGhpcy50b2dnbGVFbGVtZW50ID9cbiAgICAgICAgdGhpcy50b2dnbGVFbGVtZW50IDogdGhpcy5kZWZhdWx0VG9nZ2xlRWxlbWVudCA/XG4gICAgICAgICAgdGhpcy5kZWZhdWx0VG9nZ2xlRWxlbWVudC5uYXRpdmVFbGVtZW50IDogbnVsbDtcbiAgICBpZiAodG9nZ2xlTmF0aXZlRWxlbWVudCkge1xuICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKHRoaXMucmVuZGVyZXIyLmxpc3Rlbih0b2dnbGVOYXRpdmVFbGVtZW50LCAnY2xpY2snLCAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgdGhpcy50b2dnbGVEcm9wZG93bihldmVudCk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG5nT25EZXN0cm95XG4gICAqL1xuICBuZ09uRGVzdHJveSgpIHtcbiAgICB0aGlzLnVuQmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIHJlbW92ZUxpc3RlbmVycyh0aGlzLmxpc3RlbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogW3RvZ2dsZSBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCB0b2dnbGVcbiAgICogQHBhcmFtIGV2ZW50IFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHB1YmxpYyB0b2dnbGVEcm9wZG93bihldmVudDogRXZlbnQpOiB2b2lkIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuaXNDb2xsYXBzZWQgPSAhdGhpcy5pc0NvbGxhcHNlZDtcbiAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgc2V0VGltZW91dCAoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnVuQmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBbY29sbGFwc2VTdGFydCBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBjb2xsYXBzZVN0YXJ0XG4gICAqIEBwYXJhbSBldmVudCBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBwdWJsaWMgY29sbGFwc2VTdGFydChldmVudDogQW5pbWF0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29sbGFwc2VTdGFydC5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbY29sbGFwc2VEb25lIGRlc2NyaXB0aW9uXVxuICAgKiBAbWV0aG9kIGNvbGxhcHNlRG9uZVxuICAgKiBAcGFyYW0gZXZlbnQgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgcHVibGljIGNvbGxhcHNlRG9uZShldmVudDogQW5pbWF0aW9uRXZlbnQpOiB2b2lkIHtcbiAgICB0aGlzLm9uQ29sbGFwc2VTdGFydC5lbWl0KGV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbYmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lciBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBiaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyXG4gICAqL1xuICBwcml2YXRlIGJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy5kb2N1bWVudENsaWNrTGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyMi5saXN0ZW4oJ2RvY3VtZW50JywgJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnVuQmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBbdW5CaW5kRG9jdW1lbnRDbGlja0xpc3RlbmVyIGRlc2NyaXB0aW9uXVxuICAgKiBAbWV0aG9kIHVuQmluZERvY3VtZW50Q2xpY2tMaXN0ZW5lclxuICAgKi9cbiAgcHJpdmF0ZSB1bkJpbmREb2N1bWVudENsaWNrTGlzdGVuZXIoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZG9jdW1lbnRDbGlja0xpc3RlbmVyKSB7XG4gICAgICB0aGlzLmRvY3VtZW50Q2xpY2tMaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxufVxuIl19