/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, ContentChildren, EventEmitter, Input, NgZone, Output, QueryList, Renderer2, TemplateRef, ViewChild, ViewChildren } from '@angular/core';
import { TabToggleDirective } from './tabs.directive';
import { removeListeners, removeSubscriptions } from '../helpers';
export class TabHeaderComponent {
}
TabHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
TabHeaderComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
if (false) {
    /** @type {?} */
    TabHeaderComponent.prototype.templateRef;
}
export class TabContentComponent {
}
TabContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab-content',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
TabContentComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
if (false) {
    /** @type {?} */
    TabContentComponent.prototype.templateRef;
}
export class TabComponent {
    constructor() {
        this.isActive = false;
    }
    /**
     * \@method ngOnInit
     * @return {?}
     */
    ngOnInit() {
        if (this.tabContentComponent) {
            this.contentTemplateRef = this.tabContentComponent.templateRef;
        }
        else {
            this.contentTemplateRef = this.templateRef;
        }
    }
}
TabComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tab',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
TabComponent.propDecorators = {
    header: [{ type: Input }],
    isDisabled: [{ type: Input }],
    tabColor: [{ type: Input }],
    templateRef: [{ type: ViewChild, args: ['templateRef',] }],
    tabHeaderComponent: [{ type: ContentChild, args: [TabHeaderComponent,] }],
    tabContentComponent: [{ type: ContentChild, args: [TabContentComponent,] }]
};
if (false) {
    /** @type {?} */
    TabComponent.prototype.index;
    /** @type {?} */
    TabComponent.prototype.isActive;
    /** @type {?} */
    TabComponent.prototype.contentTemplateRef;
    /** @type {?} */
    TabComponent.prototype.header;
    /** @type {?} */
    TabComponent.prototype.isDisabled;
    /** @type {?} */
    TabComponent.prototype.tabColor;
    /** @type {?} */
    TabComponent.prototype.templateRef;
    /** @type {?} */
    TabComponent.prototype.tabHeaderComponent;
    /** @type {?} */
    TabComponent.prototype.tabContentComponent;
}
export class TabsHeaderComponent {
}
TabsHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tabs-header',
                template: '<ng-template #templateRef><ng-content></ng-content></ng-template>',
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
TabsHeaderComponent.propDecorators = {
    templateRef: [{ type: ViewChild, args: ['templateRef',] }]
};
if (false) {
    /** @type {?} */
    TabsHeaderComponent.prototype.templateRef;
}
export class TabsComponent {
    /**
     * \@method constructor
     * @param {?} changeDetectorRef [description]
     * @param {?} ngZone            [description]
     * @param {?} renderer2         [description]
     */
    constructor(changeDetectorRef, ngZone, renderer2) {
        this.changeDetectorRef = changeDetectorRef;
        this.ngZone = ngZone;
        this.renderer2 = renderer2;
        this.listeners = [];
        this.subscriptions = [];
        this.headerStyleClass = 'header pull-left';
        this.navStyleClass = 'nav nav-tabs';
        this.contentStyleClass = 'tab-content';
        this.styleClass = 'nav-tabs-custom';
        this.onClose = new EventEmitter();
        this.onOpen = new EventEmitter();
    }
    /**
     * @param {?} index
     * @return {?}
     */
    set activeTabIndex(index) {
        this.activatedTabIndex = index;
        this.changeDetectorRef.detectChanges();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterContentInit() {
        // Set tab index on load.
        this.setTabIndex();
        // Update tab index if tabs is updated.
        this.subscriptions.push(this.tabs.changes.subscribe(() => {
            this.setTabIndex();
        }));
        // Open tab on load.
        this.openTabIndex();
    }
    /**
     * \@method ngAfterViewInit
     * @return {?}
     */
    ngAfterViewInit() {
        // Set tab toggles on load.
        this.setTabsToggle();
        // Update tab toggles if tabs is updated.
        this.subscriptions.push(this.tabToggleDirectives.changes.subscribe(() => {
            this.setTabsToggle();
        }));
    }
    /**
     * \@method ngOnChanges
     * @param {?} changes [description]
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes["activeTabIndex"]) {
            this.openTabIndex();
        }
    }
    /**
     * \@method ngOnDestroy
     * @return {?}
     */
    ngOnDestroy() {
        removeListeners(this.listeners);
        removeSubscriptions(this.subscriptions);
    }
    /**
     * [toggleTab description]
     * \@method toggleTab
     * @return {?}
     */
    openTabIndex() {
        if (this.tabs) {
            this.tabs.forEach((tab) => {
                if (this.activatedTabIndex === tab.index || (this.activatedTabIndex === undefined && tab.index === 0)) {
                    tab.isActive = true;
                    this.onOpen.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
                else if (tab.isActive) {
                    tab.isActive = false;
                    this.onClose.emit({ index: tab.index });
                    this.changeDetectorRef.detectChanges();
                }
            });
        }
    }
    /**
     * [openTab description]
     * \@method openTab
     * @param {?} event     [description]
     * @param {?} tabToOpen [description]
     * @return {?}
     */
    openTab(event, tabToOpen) {
        event.preventDefault();
        tabToOpen.isActive = true;
        this.onOpen.emit({ event, index: tabToOpen.index });
        this.tabs.forEach((tab) => {
            if (tab.isActive && tabToOpen !== tab) {
                tab.isActive = false;
                this.onClose.emit({ event, index: tab.index });
            }
        });
    }
    /**
     * [setTabIndex description]
     * \@method setTabIndex
     * @return {?}
     */
    setTabIndex() {
        this.tabs.forEach((tab, index) => {
            tab.index = index;
        });
        this.changeDetectorRef.detectChanges();
    }
    /**
     * [setTabsToggle description]
     * \@method setTabsToggle
     * @return {?}
     */
    setTabsToggle() {
        this.listeners = removeListeners(this.listeners);
        this.ngZone.runOutsideAngular(() => {
            this.tabToggleDirectives.forEach((tabToggle) => {
                this.listeners.push(this.renderer2.listen(tabToggle.elementRef.nativeElement, 'click', (event) => {
                    this.openTab(event, tabToggle.tabComponent);
                    this.changeDetectorRef.detectChanges();
                }));
            });
        });
    }
}
TabsComponent.decorators = [
    { type: Component, args: [{
                selector: 'mk-tabs',
                template: `<div [ngClass]="styleClass">
  <ul [ngClass]="navStyleClass" [class.pull-right]="header || tabsHeaderComponent">
    <li *ngFor="let tab of tabs" [class.active]="tab.isActive" [mkColor]="tab.tabColor || tabsColor" mkColorProperty="border-top-color">
      <a *ngIf="!tab.isDisabled" [mkTabToggle]="tab" href="#">
        {{tab.header}}
        <ng-template *ngIf="!tab.header" [ngTemplateOutlet]="tab.tabHeaderComponent?.templateRef"></ng-template>
      </a>
      <ng-template [ngIf]="tab.isDisabled">
        {{tab.header}}
        <ng-template *ngIf="!tab.header" [ngTemplateOutlet]="tab.tabHeaderComponent.templateRef"></ng-template>
      </ng-template>
    </li>
    <li *ngIf="tabsHeaderComponent || header" [ngClass]="headerStyleClass">
      {{header}}
      <ng-template *ngIf="!header" [ngTemplateOutlet]="tabsHeaderComponent.templateRef"></ng-template>
    </li>
  </ul>
  <div [ngClass]="contentStyleClass">
    <div *ngFor="let tab of tabs" class="tab-pane" [class.active]="tab.isActive">
      <ng-template [ngTemplateOutlet]="tab.contentTemplateRef"></ng-template>
    </div>
  </div>
</div>
`,
                styles: [`.nav-tabs-custom>.nav-tabs>li{border-top-width:0}.nav-tabs-custom>.nav-tabs>li.active{border-top-width:3px}`],
                changeDetection: ChangeDetectionStrategy.OnPush
            },] },
];
/** @nocollapse */
TabsComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: NgZone },
    { type: Renderer2 }
];
TabsComponent.propDecorators = {
    activeTabIndex: [{ type: Input }],
    header: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    navStyleClass: [{ type: Input }],
    contentStyleClass: [{ type: Input }],
    styleClass: [{ type: Input }],
    tabsColor: [{ type: Input }],
    onClose: [{ type: Output }],
    onOpen: [{ type: Output }],
    tabsHeaderComponent: [{ type: ContentChild, args: [TabsHeaderComponent,] }],
    tabs: [{ type: ContentChildren, args: [TabComponent,] }],
    tabToggleDirectives: [{ type: ViewChildren, args: [TabToggleDirective,] }]
};
if (false) {
    /** @type {?} */
    TabsComponent.prototype.activatedTabIndex;
    /** @type {?} */
    TabsComponent.prototype.listeners;
    /** @type {?} */
    TabsComponent.prototype.subscriptions;
    /** @type {?} */
    TabsComponent.prototype.header;
    /** @type {?} */
    TabsComponent.prototype.headerStyleClass;
    /** @type {?} */
    TabsComponent.prototype.navStyleClass;
    /** @type {?} */
    TabsComponent.prototype.contentStyleClass;
    /** @type {?} */
    TabsComponent.prototype.styleClass;
    /** @type {?} */
    TabsComponent.prototype.tabsColor;
    /** @type {?} */
    TabsComponent.prototype.onClose;
    /** @type {?} */
    TabsComponent.prototype.onOpen;
    /** @type {?} */
    TabsComponent.prototype.tabsHeaderComponent;
    /** @type {?} */
    TabsComponent.prototype.tabs;
    /** @type {?} */
    TabsComponent.prototype.tabToggleDirectives;
    /** @type {?} */
    TabsComponent.prototype.changeDetectorRef;
    /** @type {?} */
    TabsComponent.prototype.ngZone;
    /** @type {?} */
    TabsComponent.prototype.renderer2;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWFkbWluLWx0ZS8iLCJzb3VyY2VzIjpbImxpYi90YWJzL3RhYnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBR0wsdUJBQXVCLEVBQ3ZCLGlCQUFpQixFQUNqQixTQUFTLEVBQ1QsWUFBWSxFQUNaLGVBQWUsRUFDZixZQUFZLEVBQ1osS0FBSyxFQUNMLE1BQU0sRUFJTixNQUFNLEVBQ04sU0FBUyxFQUNULFNBQVMsRUFFVCxXQUFXLEVBQ1gsU0FBUyxFQUNULFlBQVksRUFDYixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUV0RCxPQUFPLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixFQUFFLE1BQU0sWUFBWSxDQUFDO0FBWWxFLE1BQU07OztZQUxMLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsZUFBZTtnQkFDekIsUUFBUSxFQUFFLG1FQUFtRTtnQkFDN0UsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07YUFDaEQ7OzswQkFFRSxTQUFTLFNBQUMsYUFBYTs7Ozs7O0FBWTFCLE1BQU07OztZQUxMLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsZ0JBQWdCO2dCQUMxQixRQUFRLEVBQUUsbUVBQW1FO2dCQUM3RSxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTTthQUNoRDs7OzBCQUVFLFNBQVMsU0FBQyxhQUFhOzs7Ozs7QUFXMUIsTUFBTTs7d0JBRWMsS0FBSzs7Ozs7O0lBZ0J2QixRQUFRO1FBQ04sRUFBRSxDQUFDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLG1CQUFtQixDQUFDLFdBQVcsQ0FBQztTQUNoRTtRQUFDLElBQUksQ0FBQyxDQUFDO1lBQ04sSUFBSSxDQUFDLGtC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Q29udGVudEluaXQsXG4gIEFmdGVyVmlld0luaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRXZlbnRFbWl0dGVyLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBPdXRwdXQsXG4gIFF1ZXJ5TGlzdCxcbiAgUmVuZGVyZXIyLFxuICBTaW1wbGVDaGFuZ2UsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDaGlsZHJlblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgVGFiVG9nZ2xlRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJzLmRpcmVjdGl2ZSc7XG5cbmltcG9ydCB7IHJlbW92ZUxpc3RlbmVycywgcmVtb3ZlU3Vic2NyaXB0aW9ucyB9IGZyb20gJy4uL2hlbHBlcnMnO1xuXG4vLyBAVE9ETyBWZXJ0aWNhbCB0YWJzXG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay10YWItaGVhZGVyJyxcbiAgdGVtcGxhdGU6ICc8bmctdGVtcGxhdGUgI3RlbXBsYXRlUmVmPjxuZy1jb250ZW50PjwvbmctY29udGVudD48L25nLXRlbXBsYXRlPicsXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRhYkhlYWRlckNvbXBvbmVudCB7XG4gIEBWaWV3Q2hpbGQoJ3RlbXBsYXRlUmVmJykgcHVibGljIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xufVxuXG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay10YWItY29udGVudCcsXG4gIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZVJlZj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT4nLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUYWJDb250ZW50Q29tcG9uZW50IHtcbiAgQFZpZXdDaGlsZCgndGVtcGxhdGVSZWYnKSBwdWJsaWMgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG59XG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay10YWInLFxuICB0ZW1wbGF0ZTogJzxuZy10ZW1wbGF0ZSAjdGVtcGxhdGVSZWY+PG5nLWNvbnRlbnQ+PC9uZy1jb250ZW50PjwvbmctdGVtcGxhdGU+JyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgVGFiQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHVibGljIGluZGV4OiBudW1iZXI7XG4gIHB1YmxpYyBpc0FjdGl2ZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgY29udGVudFRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXI6IHN0cmluZztcbiAgQElucHV0KCkgcHVibGljIGlzRGlzYWJsZWQ6IGJvb2xlYW47XG4gIEBJbnB1dCgpIHB1YmxpYyB0YWJDb2xvcjogc3RyaW5nO1xuXG4gIEBWaWV3Q2hpbGQoJ3RlbXBsYXRlUmVmJykgcHVibGljIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gIEBDb250ZW50Q2hpbGQoVGFiSGVhZGVyQ29tcG9uZW50KSBwdWJsaWMgdGFiSGVhZGVyQ29tcG9uZW50OiBUYWJIZWFkZXJDb21wb25lbnQ7XG4gIEBDb250ZW50Q2hpbGQoVGFiQ29udGVudENvbXBvbmVudCkgcHVibGljIHRhYkNvbnRlbnRDb21wb25lbnQ6IFRhYkNvbnRlbnRDb21wb25lbnQ7XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmdPbkluaXRcbiAgICovXG4gIG5nT25Jbml0KCkge1xuICAgIGlmICh0aGlzLnRhYkNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgIHRoaXMuY29udGVudFRlbXBsYXRlUmVmID0gdGhpcy50YWJDb250ZW50Q29tcG9uZW50LnRlbXBsYXRlUmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmNvbnRlbnRUZW1wbGF0ZVJlZiA9IHRoaXMudGVtcGxhdGVSZWY7XG4gICAgfVxuICB9XG59XG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay10YWJzLWhlYWRlcicsXG4gIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlICN0ZW1wbGF0ZVJlZj48bmctY29udGVudD48L25nLWNvbnRlbnQ+PC9uZy10ZW1wbGF0ZT4nLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaFxufSlcbmV4cG9ydCBjbGFzcyBUYWJzSGVhZGVyQ29tcG9uZW50IHtcbiAgQFZpZXdDaGlsZCgndGVtcGxhdGVSZWYnKSBwdWJsaWMgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT47XG59XG5cbi8qXG4gKlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdtay10YWJzJyxcbiAgdGVtcGxhdGU6IGA8ZGl2IFtuZ0NsYXNzXT1cInN0eWxlQ2xhc3NcIj5cbiAgPHVsIFtuZ0NsYXNzXT1cIm5hdlN0eWxlQ2xhc3NcIiBbY2xhc3MucHVsbC1yaWdodF09XCJoZWFkZXIgfHwgdGFic0hlYWRlckNvbXBvbmVudFwiPlxuICAgIDxsaSAqbmdGb3I9XCJsZXQgdGFiIG9mIHRhYnNcIiBbY2xhc3MuYWN0aXZlXT1cInRhYi5pc0FjdGl2ZVwiIFtta0NvbG9yXT1cInRhYi50YWJDb2xvciB8fCB0YWJzQ29sb3JcIiBta0NvbG9yUHJvcGVydHk9XCJib3JkZXItdG9wLWNvbG9yXCI+XG4gICAgICA8YSAqbmdJZj1cIiF0YWIuaXNEaXNhYmxlZFwiIFtta1RhYlRvZ2dsZV09XCJ0YWJcIiBocmVmPVwiI1wiPlxuICAgICAgICB7e3RhYi5oZWFkZXJ9fVxuICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhdGFiLmhlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi50YWJIZWFkZXJDb21wb25lbnQ/LnRlbXBsYXRlUmVmXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICAgIDwvYT5cbiAgICAgIDxuZy10ZW1wbGF0ZSBbbmdJZl09XCJ0YWIuaXNEaXNhYmxlZFwiPlxuICAgICAgICB7e3RhYi5oZWFkZXJ9fVxuICAgICAgICA8bmctdGVtcGxhdGUgKm5nSWY9XCIhdGFiLmhlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi50YWJIZWFkZXJDb21wb25lbnQudGVtcGxhdGVSZWZcIj48L25nLXRlbXBsYXRlPlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L2xpPlxuICAgIDxsaSAqbmdJZj1cInRhYnNIZWFkZXJDb21wb25lbnQgfHwgaGVhZGVyXCIgW25nQ2xhc3NdPVwiaGVhZGVyU3R5bGVDbGFzc1wiPlxuICAgICAge3toZWFkZXJ9fVxuICAgICAgPG5nLXRlbXBsYXRlICpuZ0lmPVwiIWhlYWRlclwiIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYnNIZWFkZXJDb21wb25lbnQudGVtcGxhdGVSZWZcIj48L25nLXRlbXBsYXRlPlxuICAgIDwvbGk+XG4gIDwvdWw+XG4gIDxkaXYgW25nQ2xhc3NdPVwiY29udGVudFN0eWxlQ2xhc3NcIj5cbiAgICA8ZGl2ICpuZ0Zvcj1cImxldCB0YWIgb2YgdGFic1wiIGNsYXNzPVwidGFiLXBhbmVcIiBbY2xhc3MuYWN0aXZlXT1cInRhYi5pc0FjdGl2ZVwiPlxuICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInRhYi5jb250ZW50VGVtcGxhdGVSZWZcIj48L25nLXRlbXBsYXRlPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvZGl2PlxuYCxcbiAgc3R5bGVzOiBbYC5uYXYtdGFicy1jdXN0b20+Lm5hdi10YWJzPmxpe2JvcmRlci10b3Atd2lkdGg6MH0ubmF2LXRhYnMtY3VzdG9tPi5uYXYtdGFicz5saS5hY3RpdmV7Ym9yZGVyLXRvcC13aWR0aDozcHh9YF0sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoXG59KVxuZXhwb3J0IGNsYXNzIFRhYnNDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlckNvbnRlbnRJbml0LCBBZnRlclZpZXdJbml0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSB7XG4gIHByaXZhdGUgYWN0aXZhdGVkVGFiSW5kZXg6IG51bWJlcjtcbiAgcHJpdmF0ZSBsaXN0ZW5lcnMgPSBbXTtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zID0gW107XG5cbiAgQElucHV0KCkgcHVibGljIHNldCBhY3RpdmVUYWJJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgdGhpcy5hY3RpdmF0ZWRUYWJJbmRleCA9IGluZGV4O1xuICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG4gIEBJbnB1dCgpIHB1YmxpYyBoZWFkZXI6IHN0cmluZztcbiAgQElucHV0KCkgcHVibGljIGhlYWRlclN0eWxlQ2xhc3MgPSAnaGVhZGVyIHB1bGwtbGVmdCc7XG4gIEBJbnB1dCgpIHB1YmxpYyBuYXZTdHlsZUNsYXNzID0gJ25hdiBuYXYtdGFicyc7XG4gIEBJbnB1dCgpIHB1YmxpYyBjb250ZW50U3R5bGVDbGFzcyA9ICd0YWItY29udGVudCc7XG4gIEBJbnB1dCgpIHB1YmxpYyBzdHlsZUNsYXNzID0gJ25hdi10YWJzLWN1c3RvbSc7XG4gIEBJbnB1dCgpIHB1YmxpYyB0YWJzQ29sb3I6IHN0cmluZztcblxuICBAT3V0cHV0KCkgcHVibGljIG9uQ2xvc2UgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gIEBPdXRwdXQoKSBwdWJsaWMgb25PcGVuID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIEBDb250ZW50Q2hpbGQoVGFic0hlYWRlckNvbXBvbmVudCkgcHVibGljIHRhYnNIZWFkZXJDb21wb25lbnQ6IFRhYnNIZWFkZXJDb21wb25lbnQ7XG5cbiAgQENvbnRlbnRDaGlsZHJlbihUYWJDb21wb25lbnQpIHB1YmxpYyB0YWJzOiBRdWVyeUxpc3Q8VGFiQ29tcG9uZW50PjtcblxuICBAVmlld0NoaWxkcmVuKFRhYlRvZ2dsZURpcmVjdGl2ZSkgcHVibGljIHRhYlRvZ2dsZURpcmVjdGl2ZXM6IFF1ZXJ5TGlzdDxUYWJUb2dnbGVEaXJlY3RpdmU+O1xuXG4gIC8qKlxuICAgKiBAbWV0aG9kIGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSBjaGFuZ2VEZXRlY3RvclJlZiBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSBuZ1pvbmUgICAgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqIEBwYXJhbSByZW5kZXJlcjIgICAgICAgICBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIG5nWm9uZTogTmdab25lLFxuICAgIHByaXZhdGUgcmVuZGVyZXIyOiBSZW5kZXJlcjJcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG5nQWZ0ZXJWaWV3SW5pdFxuICAgKi9cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIC8vIFNldCB0YWIgaW5kZXggb24gbG9hZC5cbiAgICB0aGlzLnNldFRhYkluZGV4KCk7XG5cbiAgICAvLyBVcGRhdGUgdGFiIGluZGV4IGlmIHRhYnMgaXMgdXBkYXRlZC5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLnRhYnMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRUYWJJbmRleCgpO1xuICAgIH0pKTtcblxuICAgIC8vIE9wZW4gdGFiIG9uIGxvYWQuXG4gICAgdGhpcy5vcGVuVGFiSW5kZXgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAbWV0aG9kIG5nQWZ0ZXJWaWV3SW5pdFxuICAgKi9cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIC8vIFNldCB0YWIgdG9nZ2xlcyBvbiBsb2FkLlxuICAgIHRoaXMuc2V0VGFic1RvZ2dsZSgpO1xuXG4gICAgLy8gVXBkYXRlIHRhYiB0b2dnbGVzIGlmIHRhYnMgaXMgdXBkYXRlZC5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaCh0aGlzLnRhYlRvZ2dsZURpcmVjdGl2ZXMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5zZXRUYWJzVG9nZ2xlKCk7XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmdPbkNoYW5nZXNcbiAgICogQHBhcmFtIGNoYW5nZXMgW2Rlc2NyaXB0aW9uXVxuICAgKi9cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczoge1twcm9wS2V5OiBzdHJpbmddOiBTaW1wbGVDaGFuZ2V9KSB7XG4gICAgaWYgKGNoYW5nZXMuYWN0aXZlVGFiSW5kZXgpIHtcbiAgICAgIHRoaXMub3BlblRhYkluZGV4KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBtZXRob2QgbmdPbkRlc3Ryb3lcbiAgICovXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHJlbW92ZUxpc3RlbmVycyh0aGlzLmxpc3RlbmVycyk7XG4gICAgcmVtb3ZlU3Vic2NyaXB0aW9ucyh0aGlzLnN1YnNjcmlwdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFt0b2dnbGVUYWIgZGVzY3JpcHRpb25dXG4gICAqIEBtZXRob2QgdG9nZ2xlVGFiXG4gICAqL1xuICBwdWJsaWMgb3BlblRhYkluZGV4KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnRhYnMpIHtcbiAgICAgIHRoaXMudGFicy5mb3JFYWNoKCh0YWI6IFRhYkNvbXBvbmVudCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWRUYWJJbmRleCA9PT0gdGFiLmluZGV4IHx8ICh0aGlzLmFjdGl2YXRlZFRhYkluZGV4ID09PSB1bmRlZmluZWQgJiYgdGFiLmluZGV4ID09PSAwKSkge1xuICAgICAgICAgIHRhYi5pc0FjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5vbk9wZW4uZW1pdCh7aW5kZXg6IHRhYi5pbmRleH0pO1xuICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhYi5pc0FjdGl2ZSkge1xuICAgICAgICAgIHRhYi5pc0FjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMub25DbG9zZS5lbWl0KHtpbmRleDogdGFiLmluZGV4fSk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBbb3BlblRhYiBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBvcGVuVGFiXG4gICAqIEBwYXJhbSBldmVudCAgICAgW2Rlc2NyaXB0aW9uXVxuICAgKiBAcGFyYW0gdGFiVG9PcGVuIFtkZXNjcmlwdGlvbl1cbiAgICovXG4gIHB1YmxpYyBvcGVuVGFiKGV2ZW50OiBFdmVudCwgdGFiVG9PcGVuOiBUYWJDb21wb25lbnQpOiB2b2lkIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRhYlRvT3Blbi5pc0FjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5vbk9wZW4uZW1pdCh7ZXZlbnQsIGluZGV4OiB0YWJUb09wZW4uaW5kZXh9KTtcbiAgICB0aGlzLnRhYnMuZm9yRWFjaCgodGFiOiBUYWJDb21wb25lbnQpID0+IHtcbiAgICAgIGlmICh0YWIuaXNBY3RpdmUgJiYgdGFiVG9PcGVuICE9PSB0YWIpIHtcbiAgICAgICAgdGFiLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMub25DbG9zZS5lbWl0KHtldmVudCwgaW5kZXg6IHRhYi5pbmRleH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFtzZXRUYWJJbmRleCBkZXNjcmlwdGlvbl1cbiAgICogQG1ldGhvZCBzZXRUYWJJbmRleFxuICAgKi9cbiAgcHJpdmF0ZSBzZXRUYWJJbmRleCgpOiB2b2lkIHtcbiAgICB0aGlzLnRhYnMuZm9yRWFjaCgodGFiOiBUYWJDb21wb25lbnQsIGluZGV4OiBudW1iZXIpID0+IHtcbiAgICAgIHRhYi5pbmRleCA9IGluZGV4O1xuICAgIH0pO1xuICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICB9XG5cbiAgLyoqXG4gICAqIFtzZXRUYWJzVG9nZ2xlIGRlc2NyaXB0aW9uXVxuICAgKiBAbWV0aG9kIHNldFRhYnNUb2dnbGVcbiAgICovXG4gIHByaXZhdGUgc2V0VGFic1RvZ2dsZSgpOiB2b2lkIHtcbiAgICB0aGlzLmxpc3RlbmVycyA9IHJlbW92ZUxpc3RlbmVycyh0aGlzLmxpc3RlbmVycyk7XG4gICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy50YWJUb2dnbGVEaXJlY3RpdmVzLmZvckVhY2goKHRhYlRvZ2dsZTogVGFiVG9nZ2xlRGlyZWN0aXZlKSA9PiB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2godGhpcy5yZW5kZXJlcjIubGlzdGVuKHRhYlRvZ2dsZS5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgIHRoaXMub3BlblRhYihldmVudCwgdGFiVG9nZ2xlLnRhYkNvbXBvbmVudCk7XG4gICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG4iXX0=